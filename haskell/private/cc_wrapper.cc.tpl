// CC toolchain wrapper
//
// Usage: cc_wrapper [ARG]...
//
// Wraps the C compiler of the Bazel CC toolchain. Transforms arguments to work
// around limitations of Bazel and GHC and passes those via response file to the C
// compiler.
//
// - Shortens library search paths to stay below maximum path length on Windows.
//
//     GHC generates library search paths that contain redundant up-level
//     references (..). This can exceed the maximum path length on Windows, which
//     will cause linking failures. This wrapper shortens library search paths to
//     avoid that issue.
//
// - Shortens rpaths and load commands on macOS.
//
//     The rpaths and load commands generated by GHC and Bazel can quickly exceed
//     the MACH-O header size limit on macOS. This wrapper shortens and combines
//     rpaths and load commands to avoid exceeding that limit.
//
// - Finds .so files if only .dylib are searched on macOS.
//
//     Bazel's cc_library will generate .so files for dynamic libraries even on
//     macOS. GHC strictly expects .dylib files on macOS. This wrapper hooks into
//     gcc's --print-file-name feature to work around this mismatch in file
//     extension.

#include <cstring>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>

using std::move;
using std::string;
using std::vector;

const char *WORKSPACE = "{:workspace:}";
const char *CC = "{:cc:}";
const char *INSTALL_NAME_TOOL = "/usr/bin/install_name_tool";
const char *OTOOL = "/usr/bin/otool";

// -------------------------------------------------------------------
// parse arguments

enum class flag_type {
    output,  // -o
    library,  // -l, --library
    library_path,  // -L, --library-path
    print_file_name,  // --print-file-name
    stage,  // -c, -S, -E
    rpath,  // -Xlinker -rpath, -Wl,-rpath
    response_file,  // @rsp
    other
};

struct compiler_flag {
    compiler_flag(flag_type type, string flag) : type(type), flag(move(flag)) {}
    compiler_flag(flag_type type, string flag, string argument)
        : type(type), flag(move(flag)), argument(move(argument)) {}
    flag_type type;
    string flag;
    string argument;
};

template <class InputIter>
vector<compiler_flag>
parse_compiler_flags(InputIter first, InputIter last) {
    vector<compiler_flag> output;
    auto get_argument = [&output, &first, const &last](string const &flag, string &argument_out) -> bool {
        if (first != last) {
            argument_out = *++first;
            return true;
        } else {
            output.push_back(compiler_flag(flag_type::other, flag));
        }
    };
    for (; first != last; ++first) {
        string flag = *first;
        string argument;
        if (flag == "-o") {
            if (get_argument(flag, argument)) {
                output.push_back(compiler_flag(flag_type::output, flag, argument));
            }
        } else if (flag == "-l" || flag == "--library") {
            if (get_argument(flag, argument)) {
                output.push_back(compiler_flag(flag_type::library, flag, argument));
            }
        } else if (starts_with(flag, "-l")) {
            output.push_back(compiler_flag(flag_type::library, "-l", flag.substr(2)));
        } else if (starts_with(flag, "--library=")) {
            output.push_back(compiler_flag(flag_type::library, "--library", flag.substr(10)));
        } else if (flag == "-L" || flag == "--library-path") {
            if (get_argument(flag, argument)) {
                output.push_back(compiler_flag(flag_type::library_path, flag, argument));
            }
        } else if (starts_with(flag, "-L")) {
            output.push_back(compiler_flag(flag_type::library_path, "-L", flag.substr(2)));
        } else if (starts_with(flag, "--library-path=")) {
            output.push_back(compiler_flag(flag_type::library, "--library-path", flag.substr(15)));
        } else if (flag == "--print-file-name") {
            if (get_argument(flag, argument)) {
                output.push_back(compiler_flag(flag_type::print_file_name, flag, argument));
            }
        } else if (flag == "-c" || flag == "-S" || flag == "-c") {
            output.push_back(compiler_flag(flag_type::stage, flag));
        }
    }
}

vector<string>
load_response_files(vector<string> const &args) {
    vector<string> output;
    bool install_name = false;
    for (auto const &arg : args) {
        // macOS only: The install_name may start with an '@' character.
        if (install_name) {
            output.push_back(arg);
            install_name = false;
        } else if (arg == "-install_name") {
            output.push_back(arg);
            install_name = true;
        } else if (arg[0] == '@') {
            std::ifstream rsp(arg.c_str() + 1, std::ios::in);
            if (!rsp.is_open()) {
                // Couldn't open response file. No arguments to load, just
                // forward to CC.
                output.push_back(arg);
            } else {
                string line;
                while (std::getline(rsp, line)) {
                    std::stringstream linestream(line);
                    output.emplace_back();
                    linestream >> std::quoted(output.back());
                }
            }
        } else {
            output.push_back(arg);
        }
    }
    return output;
}

enum class action_type {
    print_file_name, link, other
};

struct command_line {
    action_type action;
    vector<string> args;

    // print_file_name
    string print_file_name;

    // link
    string output;
    vector<string> libraries;
    vector<string> rpaths;
};

bool starts_with(string const &str, string const &prefix) {
    return str.substr(0, prefix.size()) == prefix;
}

command_line parse_args(int argc, char **argv) {

    // Copy arguments into vector.
    vector<string> input;
    input.reserve(argc);
    for (int i = 1; i < argc; ++i) {
        input.emplace_back(argv[i]);
    }

    // Load response files.
    vector<string> loaded = load_response_files(input);

    // Parse all arguments.
    command_line output;
    output.action = action_type::link;
    bool parse_o = false;  // Last arg was -o
    bool parse_l = false;  // Last arg was -l, --library
    bool parse_print_file_name = false;  // Last arg was --print-file-name
    bool parse_linker = false;  // Last arg was -Xlinker
    bool parse_rpath = false;  // Last linker arg was -rpath
    auto handle_linker_flag = [&output, &parse_rpath](string const &arg) {
        if (parse_rpath) {
            parse_rpath = false;
            output.rpaths.push_back(arg);
        } else if (arg == "-rpath") {
            parse_rpath = true;
        } else if (starts_with(arg, "-rpath=")) {
            output.rpaths.push_back(arg.substr(7));
        } else {
            output.args.push_back("-Xlinker");
            output.args.push_back(arg);
        }
    };
    for (auto const &arg : loaded) {
        if (parse_o) {
            parse_o = false;
            output.output = arg;
            output.args.push_back("-o");
            output.args.push_back(arg);
        } else if (parse_l) {
            parse_l = false;
            output.libraries.push_back(arg);
            output.args.push_back("-l");
            output.args.push_back(arg);
        } else if (parse_print_file_name) {
            parse_print_file_name = false;
            output.action = action_type::print_file_name;
            output.print_file_name = arg;
        } else if (parse_linker) {
            parse_linker = false;
            handle_linker_flag(arg);
        } else if (arg == "-o") {
            parse_o = true;
        } else if (arg == "-l" || arg == "--library") {
            parse_l = true;
        } else if (arg == "--print-file-name") {
            parse_print_file_name = true;
        } else if (arg == "-Xlinker") {
            parse_linker = true;
        } else if (arg == "-c" || arg == "-x") {
            output.action = action_type::other;
            output.args.push_back(arg);
        } else if (starts_with(arg, "-l")) {
            output.libraries.push_back(arg.substr(2));
            output.args.push_back(arg);
        } else if (starts_with(arg, "--library=")) {
            output.libraries.push_back(arg.substr(10));
            output.args.push_back(arg);
        } else if (starts_with(arg, "-Wl,")) {
            char const *start = arg.c_str() + 4;
            char const *fin;
            while (nullptr != (fin = std::strpbrk(start, ","))) {
                handle_linker_flag(string(start, fin));
                start = fin + 1;
            };
            handle_linker_flag(string(start));
        } else {
            output.args.push_back(arg);
        }
        // XXX: Shorten library search path.
    }

    // DEBUG
    switch (output.action) {
        case action_type::link:
            std::cerr << "LINK\n";
            std::cerr << "  LIBRARIES\n";
            for (auto const &lib : output.libraries) {
                std::cerr << "    " << lib << "\n";
            }
            std::cerr << "  RPATHS\n";
            for (auto const &rpath : output.rpaths) {
                std::cerr << "    " << rpath << "\n";
            }
            break;
        case action_type::print_file_name:
            std::cerr << "PRINT_FILE_NAME\n";
            std::cerr << "  " << output.print_file_name << "\n";
            break;
        case action_type::other:
            std::cerr << "OTHER\n";
            break;
    }
    std::cerr << "  ARGS\n";
    for (auto const &arg : output.args) {
        std::cerr << "    " << arg << "\n";
    }

    return output;
}

// -------------------------------------------------------------------
// entry point

int main(int argc, char **argv) {
    std::cerr << "WORKSPACE: " << WORKSPACE << "\n";
    std::cerr << "CC: " << CC << "\n";
    parse_args(argc, argv);
}

// vim: ft=cpp
